@using System.Drawing
@using GPUDeclickerUWP.Model.Data

<h3>@Click.Position x @Click.Length</h3>
<h5>@Click.ErrorLevelDetected</h5>

<img src="data:image/gif;base64,@_imageBase64" />

@code {
    [Parameter]
    public AudioClick Click { get; set; }
    [Parameter]
    public int Width { get; set; }
    [Parameter]
    public int Height { get; set; }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();

        SetBorderColour();
        SetPolylines();

        _image = new Bitmap(Width, Height);

        var graphics = Graphics.FromImage(_image);
        graphics.Clear(Color.White);

        DrawPolyline(graphics, _input, Color.Black);
        DrawPolyline(graphics, _output, Color.Red);

        DrawBorder(graphics);

        var ms = new System.IO.MemoryStream();
        _image.Save(ms, System.Drawing.Imaging.ImageFormat.Gif);
        _imageBase64 = Convert.ToBase64String(ms.ToArray());

        graphics.Dispose();
    }

    private void DrawPolyline(Graphics graphics, PointF[] polyline, Color color)
    {
        graphics.DrawLines(new Pen(color, 1), polyline);
    }

    private void DrawBorder(Graphics graphics)
    {
        graphics.DrawRectangle(new Pen(_borderColor, 3), 0, 0, Width, Height);
    }

    private bool _isPointerPressedInTheLeftArea;
    private bool _isPointerPressedInTheMidle;
    private bool _isPointerPressedInTheRightArea;
    private Point _pointerLastPosition;
    private Point _pointPointerPressedInTheLeftArea;
    private Point _pointPointerPressedInTheMidle;
    private Point _pointPointerPressedInTheRightArea;

    private Color _borderColor;
    private PointF[] _input;
    private PointF[] _output;

    private Image _image;
    private string _imageBase64;

    private void SetBorderColour()
    {
        _borderColor = Click.Aproved
            ? Color.FromName("Aqua")
            : Color.FromName("Yellow");
    }

    /// <summary>
    ///     Forms polylines that show input and output audio samples
    /// </summary>
    private void SetPolylines()
    {
        var input = new List<PointF>();
        var output = new List<PointF>();

        // calculate position in audio track to show click
        //in the center of this CW
        var clickWindowStartPositionInAudio = (int)(
            Click.Position +
            Click.Length / 2 -
            Width / 2);

        // set Input polylyne
        for (var x = 0; x < Width; x++)
        {
            var sample = Click.GetInputSample(clickWindowStartPositionInAudio + x);
            var y = Height * (-sample + 1) / 2;
            input.Add(new PointF(x, y));
        }

        // set Output polyline two samples wider than click
        var shift = Click.Position - clickWindowStartPositionInAudio;
        for (var x = shift - 1;
            x <= shift + Click.Length + 1;
            x++)
        {
            var sample = Click.GetOutputSample(clickWindowStartPositionInAudio + x);
            var y = Height * (-sample + 1) / 2;
            output.Add(new PointF(x, y));
        }

        _input = input.ToArray();
        _output = output.ToArray();
    }

    /// <summary>
    ///     Event handler processing mouse left button or touch screen
    ///     user actions
    /// </summary>
    /// <param name="sender"></param>
    /// <param name="e"></param>
    /*private void GridPointerPressed(
        object sender,
        PointerRoutedEventArgs e)
    {
        if (!(sender is Grid grid))
            return;

        var areaPressed = PointerOnWhichArea(grid.ActualWidth, e);
        switch (areaPressed)
        {
            case Area.LeftExpand:
                // remember pointer position
                // action will be taken when poiner released
                _isPointerPressedInTheLeftArea = true;
                _pointerLastPosition = e.GetCurrentPoint(this).Position;
                _pointPointerPressedInTheLeftArea = _pointerLastPosition;
                break;
            case Area.LeftShrink:
                // shrink marked damaged sample sequence on left
                Click.ShrinkLeft();
                ThresholdLevelDetected.Text = Click.ErrorLevelDetected.ToString("0.0");
                SetPolylines();
                break;
            case Area.Midle:
                // remember pointer position
                // action will be taken when poiner released
                _isPointerPressedInTheMidle = true;
                _pointerLastPosition = e.GetCurrentPoint(this).Position;
                _pointPointerPressedInTheMidle = _pointerLastPosition;
                break;
            case Area.RightShrink:
                // shrink marked damaged sample sequence on right
                Click.ShrinkRight();
                ThresholdLevelDetected.Text = Click.ErrorLevelDetected.ToString("0.0");
                SetPolylines();
                break;
            case Area.RightExpand:
                // remember pointer position
                // action will be taken when poiner released
                _isPointerPressedInTheRightArea = true;
                _pointerLastPosition = e.GetCurrentPoint(this).Position;
                _pointPointerPressedInTheRightArea = _pointerLastPosition;
                break;
        }
    } */

    /// <summary>
    /// Defines on which of five areas of ClickWindow you can see the mouse pointer
    /// </summary>
    /// <param name="width">ClickWindow width</param>
    /// <param name="e">PointerRoutedEventArgs</param>
    /// <returns></returns>
    /*private Area PointerOnWhichArea(double width, PointerRoutedEventArgs e)
    {
        var point = e.GetCurrentPoint(this).Position;

        if (point.X < width / 6)
            return Area.LeftExpand;
        if (point.X >= width / 6 && point.X < width / 3)
            return Area.LeftShrink;
        if (point.X >= 2 * width / 3 && point.X < 5 * width / 6)
            return Area.RightShrink;
        if (point.X >= 5 * width / 6)
            return Area.RightExpand;

        return Area.Midle;
    } 

    /// <summary>
    /// Changes action notification depending on position of the pointer
    /// over ClickWindow
    /// </summary>
    /// <param name="sender"></param>
    /// <param name="e"></param>
    private void GridPointerMoved(object sender, PointerRoutedEventArgs e)
    {
        var point = e.GetCurrentPoint(this).Position;

        if (_isPointerPressedInTheLeftArea ||
            _isPointerPressedInTheMidle ||
            _isPointerPressedInTheRightArea)
            GestureProcessing(point);

        if (!(sender is Grid grid))
            return;
        var areaNavigated = PointerOnWhichArea(grid.ActualWidth, e);
        if (areaNavigated == Area.LeftExpand)
        {
            // show left arrow in LeftExpand area
            ActionNotification.Text = "\u21A4";
            ActionNotification.HorizontalAlignment = HorizontalAlignment.Left;
        }

        if (areaNavigated == Area.LeftShrink)
        {
            // show right arrow in LeftShrink area
            ActionNotification.Text = "\u21A6";
            ActionNotification.HorizontalAlignment = HorizontalAlignment.Left;
        }

        if (areaNavigated == Area.Midle)
        {
            // show on/off in Midle area
            ActionNotification.Text = "On/Off";
            ActionNotification.HorizontalAlignment = HorizontalAlignment.Center;
        }

        if (areaNavigated == Area.RightShrink)
        {
            // show left arrow in RightShrink area
            ActionNotification.Text = "\u21A4";
            ActionNotification.HorizontalAlignment = HorizontalAlignment.Right;
        }

        if (areaNavigated == Area.RightExpand)
        {
            // show right arrow in RightExpand area
            ActionNotification.Text = "\u21A6";
            ActionNotification.HorizontalAlignment = HorizontalAlignment.Right;
        }
    } */

    /// <summary>
    /// Process gestures to expand or reduce click
    /// </summary>
    /// <param name="point"></param>
    private void GestureProcessing(Point point)
    {
        const int minMovement = 3;
        var changed = false;

        if (_isPointerPressedInTheMidle)
        {
            if (point.X - _pointerLastPosition.X > minMovement)
            {
                // expand marked damaged sample sequence to right
                Click.ExpandRight();
                //ThresholdLevelDetected.Text = Click.ErrorLevelDetected.ToString("0.0");
                changed = true;
            }

            if (point.X - _pointerLastPosition.X < -minMovement)
            {
                // expand marked damaged sample sequence to right
                Click.ExpandLeft();
                //ThresholdLevelDetected.Text = Click.ErrorLevelDetected.ToString("0.0");
                changed = true;
            }
        }

        if (_isPointerPressedInTheRightArea && point.X - _pointerLastPosition.X < -minMovement)
        {
            // shrink marked damaged sample sequence on right
            Click.ShrinkRight();
            //ThresholdLevelDetected.Text = Click.ErrorLevelDetected.ToString("0.0");
            changed = true;
        }

        if (_isPointerPressedInTheLeftArea && point.X - _pointerLastPosition.X > minMovement)
        {
            // shrink marked damaged sample sequence on right
            Click.ShrinkLeft();
            //ThresholdLevelDetected.Text = Click.ErrorLevelDetected.ToString("0.0");
            changed = true;
        }

        if (!changed)
            return;

        SetPolylines();
        _pointerLastPosition = point;
    }

    /// <summary>
    /// Sets margin for ClickWindow
    /// </summary>
    /// <param name="marginLeft"></param>
    /// <param name="marginTop"></param>
    /* internal void SetMargin(double marginLeft, double marginTop)
    {
        var margin = Margin;
        margin.Left = marginLeft;
        margin.Top = marginTop;
        Margin = margin;
    }

    /// <summary>
    /// Clears action notification text and calls GridPointerReleased if
    /// user changed click length
    /// </summary>
    /// <param name="sender"></param>
    /// <param name="e"></param>
    private void GridPointerExited(object sender, PointerRoutedEventArgs e)
    {
        ActionNotification.Text = "";
        // if we are modifying click lenght then fix changes
        if (_isPointerPressedInTheLeftArea ||
            _isPointerPressedInTheMidle ||
            _isPointerPressedInTheRightArea)
            GridPointerReleased(sender, e);
    }

    /// <summary>
    ///     Event handler processing mouse left button or touch screen
    ///     user actions
    /// </summary>
    /// <param name="sender"></param>
    /// <param name="e"></param>
    private void GridPointerReleased(object sender, PointerRoutedEventArgs e)
    {
        var point = e.GetCurrentPoint(this).Position;

        if (_isPointerPressedInTheMidle &&
            Math.Abs(point.X - _pointPointerPressedInTheMidle.X) < 1 &&
            Math.Abs(point.Y - _pointPointerPressedInTheMidle.Y) < 1)
        {
            // change Aproved property of click
            Click.ChangeAproved();
            SetBorderColour();
        }

        if (_isPointerPressedInTheRightArea &&
            Math.Abs(point.X - _pointPointerPressedInTheRightArea.X) < 1 &&
            Math.Abs(point.Y - _pointPointerPressedInTheRightArea.Y) < 1)
        {
            // expand marked damaged sample sequence to right
            Click.ExpandRight();
            ThresholdLevelDetected.Text = Click.ErrorLevelDetected.ToString("0.0");
            SetPolylines();
        }

        if (_isPointerPressedInTheLeftArea &&
            Math.Abs(point.X - _pointPointerPressedInTheLeftArea.X) < 1 &&
            Math.Abs(point.Y - _pointPointerPressedInTheLeftArea.Y) < 1)
        {
            // expand marked damaged sample sequence to right
            Click.ExpandLeft();
            ThresholdLevelDetected.Text = Click.ErrorLevelDetected.ToString("0.0");
            SetPolylines();
        }

        _isPointerPressedInTheMidle = false;
        _isPointerPressedInTheRightArea = false;
        _isPointerPressedInTheLeftArea = false;
    } */

    /// <summary>
    ///     Areas of ClickWindow used to detect user actions
    /// </summary>
    private enum Area
    {
        LeftExpand,
        LeftShrink,
        Midle,
        RightShrink,
        RightExpand
    }
}
